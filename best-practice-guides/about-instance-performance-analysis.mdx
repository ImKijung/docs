---
id: about-instance-performance-analysis
title: 인스턴스 성능 관리 활용하기
description: 애플리케이션 모니터링 메뉴 중 인스턴스 성능 관리 메뉴의 주요 기능 및 활용 예시를 안내합니다.
tags: [ 애플리케이션, 애플리케이션 모니터링, APM, 고급 활용, 인스턴스 성능 관리  ]
keywords: [ 애플리케이션, 애플리케이션 모니터링, APM, 인스턴스 성능 관리 ]
toc_max_heading_level: 2
displayed_sidebar: learningSidebar
---

***인스턴스 성능 관리 메뉴***는 애플리케이션의 환경을 확인하고 성능을 관리하는데에 유용한 기능을 제공합니다. 주요 메뉴 상세 및 활용 예시를 다음과 같이 안내합니다. 

## 로딩된 클래스 {#advanced-use-loaded-classes}

홈 화면 &gt; 프로젝트 선택 &gt; <Cmdname sid="side_agentsConfiguration" className="uitext" /> &gt; <Cmdname sid="side_loadedClasses" className="uitext" />

***로딩된 클래스*** 메뉴는 애플리케이션에 로딩된 클래스 정보를 확인할 수 있습니다. 

## 스레드 목록/덤프 {#advanced-use-thread-list-dump} 

홈 화면 &gt; 프로젝트 선택 &gt; <Cmdname sid="side_agentsConfiguration" className="uitext" /> &gt; <Cmdname sid="side_threadList" className="uitext" />

{/* 스레드 목록을 보고 하는 중요한 행위-> 스레드 cpu 누적 시간 보여줌 -> 시계열 정보 확인 가능하다는 얘기를 추가하기 */}

***스레드 목록/덤프*** 메뉴는 현재 실행 중인 스레드 목록을 확인하고 해당 스레드의 개별 스냅샷 및 전체 스레드 덤프 정보를 조회할 수 있습니다. ***히트맵***이 트랜잭션 응답 시간 위주 최적화 작업의 핵심이라면 ***스레드 목록/덤프***는 CPU 최적화의 핵심 요소라고 할 수 있으며 이는 애플리케이션의 성능 최적화, 문제 진단, 그리고 안정성 유지에 중요한 역할을 합니다. 

어떤 스레드가 CPU를 많이 사용하고 있는지 파악하는 것은 병목 발생 원인 식별에 있어 중요합니다. 특히 특정 시간대에 CPU 사용이 급증한 스레드 식별을 위해 시계열 데이터를 조회할 수 있어야 합니다. ***스레드 목록/덤프*** 메뉴의 ***스레드 CPU 시간***은 해당 스레드가 CPU를 점유한 총 누적 시간을 의미합니다. ***새로 고침*** 시 현재 스레드 CPU 시간과 기존 스레드 CPU 시간의 차이인 ***스레드 CPU 델타값***을 제공하여 조회 시점에 가장 많이 CPU를 사용하고 있는 스레드를 특정할 수 있습니다. 

![스레드 목록/덤프 델타값 sc](/img/best-p/about-instance-thread-list-dump3.png)

이렇게 문제 스레드 특정 후 해당 스레드 스냅샷을 확인해 자주 호출되거나 오래 실행되는 메소드 등을 찾아낼 수 있습니다. 이를 통해 이상 징후를 조기에 발견하고 대응하여 시스템을 안정적으로 관리할 수 있습니다.

![스레드 목록/덤프 개별 스레드 덤프](/img/best-p/about-instance-thread-list-dump4.png)

:::note 

***스레드 CPU 시간*** 확인 → ***새로고침*** → ***스레드 CPU 델타값*** 기준으로 목록 정렬 → **CPU 사용량 높은 스레드 식별** 

:::

#### CPU 사용량 급증 유형

애플리케이션 CPU 사용량이 급증한 경우는 여러가지 원인에 기인할 수 있습니다. 이를 힙 메모리가 가득 찬 경우, 실제 요청이 많은 경우, 그리고 로직 문제인 경우 세 가지 유형으로 분류할 수 있습니다.

이때 가장 먼저 확인하는 것은 식별이 용이한 힙 메모리입니다. 힙 메모리가 가득 찬 경우 JVM이 GC를 빈번히 실행해 CPU 사용량이 급증할 수 있습니다. ~~특히 Full GC 발생 시 애플리케이션이 일시적으로 멈추며 CPU 사용량이 크게 상승합니다. 예를 들어 애플리케이션에서 객체가 적절히 해제되지 않고 메모리를 점유하는 메모리 누수가 발생한 경우 힙 메모리가 부족할 수 있으며 이때 메모리를 회수하기 위해 JVM이 GC를 반복적으로 실행하여 CPU 사용률이 급격히 증가하게 됩니다.~~ 이 경우 ***애플리케이션 대시보드***의 ***힙 메모리*** 그래프를 통해 쉽게 확인할 수 있습니다. 

두 번째는 실제 요청이 많은 것으로 애플리케이션이 많은 수의 클라이언트 요청을 처리해 CPU 사용량이 높아진 경우입니다. 각 요청은 자바 스레드를 생성해 처리되기에 CPU가 많은 작업을 수행하게 됩니다. ~~쇼핑몰 사이트의 대규모 할인 이벤트 등으로 웹 서퍼 트래픽이 급증한 경우를 예로 들 수 있습니다. 많은 사용자가 웹 페이지를 방문해 서버가 다수의 HTTP 요청을 처리하기 위해 마찬가지로 많은 스레드를 생성해 CPU 사용률이 크게 상승하게 됩니다.~~ 이 경우 ***애플리케이션 대시보드***에서 TPS 관련 지표를 통해 확인할 수 있습니다.

세 번째는 잘못된 코드 로직으로 문제가 발생한 경우입니다. 애플리케이션 코드에 비효율적인 알고리즘이나 무한 루프 등이 포함되어 있을 경우 CPU 사용률이 비정상적으로 높아질 수 있습니다. 이 경우 ***스레드 목록/덤프*** 메뉴를 통해 CPU 사용량이 높은 스레드를 특정 후 해당 스레드 덤프를 확인해 문제가 되는 코드를 확인할 수 있습니다.

{/* 

어떤 스레드가 CPU를 많이 사용하고 있는지 또는 어떤 스레드가 블록된 상태인지 파악하는 것은 

어떤 스레드가 CPU를 많이 사용하고 있는지 또는 어떤 스레드가 블록된 상태인지 파악해 병목 현상을 일으키는 원인을 식별할 수 있습니다. 스레드 특정 후 해당 스레드 스냅샷을 통해 자주 호출되거나 오래 실행되는 메소드 등을 찾아낼 수 있습니다. */}

{/* ### 스레드 CPU 델타값 
 
![스레드 목록/덤프](/img/best-p/about-instance-thread-list-dump1.png)

![스레드 목록/덤프 델타값](/img/best-p/about-instance-thread-list-dump2.png) */}

## 소켓 오픈 개수 {#advanced-use-opened-socket-count}
